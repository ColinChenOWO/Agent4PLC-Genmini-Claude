# Claude Code 自動化任務處理工作流程指南

本文件詳細說明了 Claude Code 在處理使用者自動化任務時應遵循的標準化工作流程和注意事項。

---

### **總體原則：**

*   **檔案組織：** 每個新任務都會先創建一個專屬的資料夾，所有相關檔案（規劃、程式碼、模型、報告）都將存放在其中。
*   **檔案覆蓋：** 在修正或更新程式碼、模型檔案時，我將直接覆蓋原始檔案，而不是創建新的檔案。
*   **語法正確性：** 嚴格遵循每種語言（ST, NuXmv）的正確語法，特別是註釋格式。
*   **優先級與時序：** 在建模和編碼時，會特別注意優先級和時序邏輯的精確轉換。
*   **重置記憶：** 每次會話重新啟動時，我的內部工作記憶和對檔案內容、任務進度的理解都會被重置。這需要我重新讀取上下文。

---

### **詳細工作流程步驟：**

1.  **起始與初始上下文讀取 (Initial Context Gathering)**
    *   **目的：** 了解當前專案的整體情況，避免重複工作，並利用現有資源。
    *   **動作：**
        *   接收新任務要求。
        *   **主動執行：** 立即啟動 `Explore` 代理來掃描當前目錄及其所有子目錄下的 `.md` 檔案，以獲取專案的相關背景資訊和現有文件摘要。
        *   分析探索結果，建立對專案的初步理解。
        *   **如果存在上次會話中未完成的子代理任務：** 嘗試使用 `Task` 工具的 `resume` 參數來恢復子代理的上下文。

2.  **任務專屬資料夾創建 (Task-Specific Folder Creation)**
    *   **目的：** 保持檔案組織清晰，將每個任務的產出隔離。
    *   **動作：**
        *   根據新任務的名稱，創建一個新的子資料夾。例如：`led_control/`。

3.  **需求擷取 (Retrieval Phase)**
    *   **目的：** 徹底理解使用者需求，澄清所有模糊之處。
    *   **動作：**
        *   仔細閱讀使用者提供的需求說明、輸入、輸出和功能要求。
        *   提出一系列具體、關鍵的澄清問題（使用 `AskUserQuestion`），以釐清模糊的邏輯、邊界條件、時序行為和期望的系統響應（例如：緊急停止後的狀態、脈衝信號的行為、待機狀態的明確定義等）。
        *   在收到使用者回覆後，生成一份詳細的「需求擷取摘要」。

4.  **規劃 (Planning Phase)**
    *   **目的：** 根據已確認的需求，設計系統的實現策略和驗證藍圖。
    *   **動作：**
        *   設計系統架構（例如：狀態機的數量和相互關係）。
        *   定義主要內部變數（例如：計時器、狀態變數、邊緣偵測變數）。
        *   詳細規劃控制邏輯、狀態定義、狀態轉換條件和每個狀態下的輸出行為。
        *   明確定義將用於形式驗證的「安全屬性 (Safety Properties)」和「活性屬性 (Liveness Properties)」，以 LTL (Linear Temporal Logic) 的形式表述。
        *   將整個規劃內容寫入一個 `.md` 檔案（例如：`parking_barrier_control/parking_barrier_plan.md`），放置在任務專屬資料夾中。
        *   向使用者請求對規劃的審核和批准。

5.  **編碼 (Coding Phase)**
    *   **目的：** 將規劃的邏輯轉換為實際可執行（或可編譯）的 Structured Text (ST) 程式碼。
    *   **動作：**
        *   根據已批准的規劃，在任務專屬資料夾中生成 Structured Text (`.st`) 程式碼檔案（例如：`parking_barrier_control/parking_barrier_controller.st`）。
        *   確保程式碼嚴格符合 ST 語法規範，包括正確的變數聲明、`CASE OF` 結構、`IF/ELSIF` 語句以及註釋格式（使用 `(* ... *)`）。

6.  **驗證 - Matiec 編譯 (Validation Phase - Matiec)**
    *   **目的：** 作為 ST 程式碼的「語法/語義檢查器」，確保程式碼符合 IEC 61131-3 標準並可編譯。
    *   **動作：**
        *   在 WSL 環境中執行 `matiec` 編譯器，並將 `.st` 檔案作為輸入。命令範例：`MSYS_NO_PATHCONV=1 wsl -e bash -lc "/usr/local/bin/matiec /mnt/c/.../your_controller.st"`。
        *   **結果處理：**
            *   **如果 `matiec` 報告錯誤：** 仔細分析錯誤訊息（例如：行號、錯誤類型），讀取 `.st` 檔案，識別程式碼中的語法或語義問題（例如：註釋格式、`CASE` 語句元素錯誤），然後**直接修正原始的 `.st` 檔案**。修正後，返回此步驟重新運行 `matiec`，直到編譯成功。
            *   **如果 `matiec` 成功（輸出 `POUS.c`, `POUS.h` 等）：** 進入下一步的 NuXmv 模型生成。

7.  **驗證 - NuXmv 模型生成 (Validation Phase - NuXmv Model Generation)**
    *   **目的：** 將 Matiec 驗證後的 ST 邏輯精確地轉換為 NuXmv 可理解的形式化模型。
    *   **動作：**
        *   根據經過 Matiec 驗證的 ST 程式碼的邏輯，在任務專屬資料夾中創建 NuXmv 模型檔案（例如：`parking_barrier_control/parking_barrier_model.smv`）。
        *   **關鍵轉換點：**
            *   **變數映射：** ST 的輸入/輸出/內部變數映射到 NuXmv 的 `VAR`。
            *   **狀態機建模：** ST 的 `CASE OF` 和 `IF/ELSIF` 邏輯需要轉換為 NuXmv 的 `next(<state_variable>) := case ... esac;`。這需要特別注意 NuXmv `case` 語句的優先級（從上到下評估）和 `next` 函數的並行賦值語義。
            *   **時序邏輯：** 複雜的時序行為（如計時器、脈衝偵測）需要仔細建模。對於像緊急停止這樣的全局、瞬時覆蓋邏輯，可能需要引入內部變數（如 `_internal`）來解耦，並在最後的輸出賦值階段應用全局覆蓋，以避免時序競態。
            *   **屬性定義：** 將規劃中定義的 LTL 安全和活性屬性寫入 `.smv` 檔案。
            *   **註釋格式：** 確保所有 NuXmv 檔案中的註釋都使用 `--`。

8.  **驗證 - NuXmv 執行與結果分析 (Validation Phase - NuXmv Execution & Analysis)**
    *   **目的：** 使用形式驗證技術檢查模型是否滿足所有定義的屬性。
    *   **動作：**
        *   在 WSL 環境中執行 `nuXmv` 模型檢查器，將 `.smv` 檔案作為輸入。命令範例：`MSYS_NO_PATHCONV=1 wsl -e bash -lc "/home/ser/nuXmv-2.0.0-Linux/bin/nuXmv /mnt/c/.../your_model.smv"`。
        *   **結果處理：**
            *   **如果 `nuXmv` 報告語法錯誤：** 分析錯誤訊息，讀取 `.smv` 檔案，修正 NuXmv 語法問題（例如：註釋格式、不正確的 `VAR` 或 `ASSIGN` 語句），然後**直接修正原始的 `.smv` 檔案**。返回此步驟重新運行 `nuXmv`。
            *   **如果 `nuXmv` 找到反例 (`is false`)：**
                *   仔細分析 `nuXmv` 提供的 LTL 反例追蹤 (Counterexample Trace)。
                *   **啟動 Debugging Agent：** 將錯誤報告、`.st` 檔案、`.smv` 檔案和規劃文件作為輸入。
                *   **Debugging Agent 結合 Retrieval Agent：** `Debugging Agent` 將分析問題，並在需要時調用 `Retrieval Agent` 搜索知識庫中相關的 ST 語法、NuXmv 建模模式或錯誤解決方案。
                *   `Debugging Agent` 根據分析和知識提供具體的修正建議。
                *   我將根據 `Debugging Agent` 的建議，**直接修正原始的 `.st` 或 `.smv` 檔案**。
                *   返回驗證步驟 6 (Matiec 編譯) 重新運行整個驗證流程，直到所有可驗證的屬性都為 `TRUE`。
            *   **如果所有屬性都為 `TRUE`：** 驗證成功。生成最終的驗證報告。
            *   **如果某些活性屬性持續失敗 (在需求允許的情況下，例如無限延長的柵欄開啟)：** 接受其失敗，並在報告中明確說明原因（例如，需要額外的環境假設）。

9.  **任務完成報告 (Task Completion Report)**
    *   **目的：** 總結整個任務的成果。
    *   **動作：**
        *   提供完整的結果摘要，包括所有屬性的驗證狀態、任何重要發現以及最終結論。
        *   提供程式碼和模型檔案的最終狀態。

---
